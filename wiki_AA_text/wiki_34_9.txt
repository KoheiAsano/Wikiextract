Pascal
Pascal（パスカル）は、ニクラウス・ヴィルトの設計（デザイン）によるコンピュータ・プログラミング言語である。ALGOL（直接的にはその一派生である、ヴィルトが関与した）などの影響があるが、個人の設計であることに由来する簡素だがよく整った言語仕様（構文と意味）を持つ。用途の中に教育を意識しており、構造化された制御構造など、その当時「良きプログラミングの慣習」と考えられていたことの影響もある。一方で批判者からは、あくまでも教育用に過ぎない言語だ、といったような評もあることにはあったが、PascalコンパイラをPascalで書ける（いわゆる言語処理系のブートストラップ）ことをはじめ、Pascalで書かれた#実用プログラム例は多くある。名前は、哲学者・数学者・科学者で、機械式計算機を製作するなど技術者でもあったブレーズ・パスカルにあやかったものである。
教育を主目的としつつ、コンパイラが記述できる程度に強力な言語を目指し、当初、ヴィルト自身がPascalコンパイラをPascal自身で書いてみせ、その能力を示した（後のModula-2では、オペレーティングシステムをModula-2で書いてみせた）。
Pascalの単純さは、例えば構文がLL(1)であることなどによく現れている。全ての名札、定数、型名、変数、サブルーチンは使用に先立って定義しておく必要がある。ポインタを用いたリストのような型の定義や、交互にサブルーチンが呼び合うためには、例外的な構文を使わねばならない。ポインタに限っては、参照される型の定義の前に、その型を参照するような定義ができた。また、サブルーチンの定義部分だけを先に記述する方法で解決した。
その結果、パーサはLL(1)パーサであり、バックエンドはいわゆるワンパスコンパイラであった。なお、他言語のコンパイラでは、2回以上走査を行うマルチパス形式のものが多かった。マルチパス形式では、最初の走査で識別子等の情報を中心に情報収集を行い、後続の走査でそれらの情報を参照しつつ実行ファイルを生成するため、コンパイル速度面では不利だが、最適化の点で有利となる。ワンパスコンパイラであることは、絶望的に遅いフロッピディスクを作業ディスクとしてビルドするユーザさえ多かった、初期のパーソナルコンピュータでは大いに利点となった。
なお、Turbo Pascalの高速性はアセンブラで記述されていたことも一因であるが、Pascalの簡潔な仕様を活かし、かつ、メモリを使える限り使ってファイルアクセスを最小限に留めることで、前述のようなパーソナルコンピュータでも高速にコンパイルできた。
ALGOL由来の制御構造、サブルーチンの中に、そのサブルーチン内からのみ見えるローカルな変数、そのサブルーチン内からのみ呼び出せるサブルーチン等を定義できるといった、スコープの概念と再帰的な構文構造（ブロック構造と呼ぶ）、静的スコープによる参照の局所化機能を持つ。さらに、豊富なデータ型と、COBOL に見られた構造体を含む新しいデータ型を定義できるという特徴も持っている。レコード型とポインタを用いてリスト、木といったデータ構造を自由に構築することができる（二分木#データの二分木への格納法の例参照）。なお由来は不明だが、最後にピリオドを付けるという、微妙にALGOLの構文と違う点がある。
注目すべきは、C言語などでもALGOLと同様としている、変数などの定義の「codice_1」といったような「型名 変数名」という順序ではなく「codice_2」というような順になる、型名を後にした記法であろう。数学などで使われる記法の類似であるのでヴィルトの完全なオリジナルだとも言えないが、最初に述べたALGOL WではALGOLと同様であるので、プログラミング言語への導入としてはオリジナリティが高いものと考えられる。この点について、JavaなどはC言語の構文の小改良にとどまっているが、LimboやGo言語などC言語を使い尽した設計者らによる新言語が、Pascalに似た記法としていることは特筆事項であろう。なお、ALGOL系ではAdaも変数などの型の記述を、これに類似した構文としている。
コンパイル時にできるだけ多くの不注意による誤りを発見できる、強く型付けされた（strongly typed）言語であり、またハードウェアを隠蔽する思想が徹底している。たとえば集合型、ポインタ型はそれぞれビットマップとアドレスを抽象化したものと考えられる。また Pascal は教育用ということもあり、最初の仕様では分割コンパイルや外部ライブラリの利用が考慮されていなかった。これは大規模なプログラムを記述したり、ハードウェアを直接操作するプログラムを記述するには不便な仕様であり、入出力の扱いなど処理系に依存しなければならない部分を言語の中に抱える結果に繋がった。たとえばファイル型変数に特定のファイルを関連付ける標準的な方法はない。ヴィルト自身は Modula-2 でこれらの要請に応える一方で、Pascalでは実装のベンダがそれぞれ独自の拡張を施して、分割コンパイルやハードウェアの直接操作を可能としたが、この部分の互換性は乏しい。
著名なものに、、などがある。
処理系に関しても、2017年現在も多くのプラットフォームに多くの実装がある。
最初のPascalコンパイラは、CDC 6000 シリーズ用に1970年に書かれた1パスコンパイラで、それ自身が Pascal で書かれていた。CDC 6000 シリーズは 1ワードが 60ビットのマシンであった。Pascal には、メモリを節約するための詰め合わせ機能(pack/unpack)や、10文字（1文字は6ビット）の詰め合わせ文字列である alfa 型の存在、長いワードをビットごとに扱うための集合型など、CDC のアーキテクチャの影響を受けた箇所がある。CDC 用のコンパイラは、extern 宣言によって外部ライブラリを読み込むことができた。
1975年にカリフォルニア工科大学で Pascal を並列動作用に拡張した Concurrent Pascal が開発され、それを使ってシングルユーザのオペレーティングシステムを開発し、Pascal がシステムプログラミングにも優れていることを明らかにした。
Pascal-P は、Pascal からP コードへのコンパイラと、Pコードインタプリタからなる中間言語コンパイラで、やはり Pascal 自身で書かれていた。このことにより、後の Java が異なるアーキテクチャの計算機への移植が進んだのと同様、多くの計算機への移植が進んだ。中間言語コンパイラを移植するためには、仮想スタックマシンであるPコードマシンのエミュレータを移植元の機械で開発し、コンパイラを移植先の機械でコンパイルするだけで良い。1970～80年代の低速な計算機では、このような中間言語方式では性能が不十分だった。
ISOではPascalを1983年に ISO 7185 として標準化し現在は1990年版である。対応する日本の規格はJIS X 3008-1990で、改訂版は1994である。標準 Pascal には水準0と水準1があり、後者は長さの異なる配列を引数に取るための整合配列が使える。
以前ならばALGOLが使われていたであろう、論文や学会誌等におけるアルゴリズムの記述に、ALGOLに代わってPascalは使われるようになった。
Pascal は、アルゴリズムの教科書にしばしば使われた。ヴィルト自身による『アルゴリズム+データ構造=プログラム』をはじめ、エイホ・ホップクロフト・ウルマン『データ構造とアルゴリズム』などは Pascal を使用している。
1970年代末のパソコン上のシステムでは、Apple II や Z80 システムで動作する UCSD Pascal（後に対応言語を増やして UCSD p-System に発展）が動いていた。UCSD Pascal はPコードを使った中間コードコンパイラで、文字列型・case文の拡張・ユニットを使った Modula-2 風の分割コンパイルなどをサポートしており、言語以外にメニューを使ったユーザーインターフェースも優れていた。
ほかに、デジタルリサーチ社 の Pascal/MT+ やJRTシステムズ社の JRT pascal（日本ではライフボートが αPascal として販売した）などが販売されていた。
1983年にBorlandが発売したTurbo Pascalは（当初はZ80マシンのCP/Mで動作する）、大変高速な1パスコンパイラ兼開発環境である。続いて8086マシン用（CP/M-86, MS-DOS）がリリースされ、1980年代後半〜1990年代前半に一般個人が所有するパーソナルコンピュータの環境として最も数の多かったMS-DOSにおいて大きな人気を得た。ビルドの高速さは、「コンパイラは、コンパイル時間があるので不便だ」という意識を、十分に速い環境であればたいして気にならないのだ、という事実を示して塗り替えた。さらにWordStar風のキー操作を持った、当時としては高機能なフルスクリーンエディタを備えていながら低価格であったため、
「Turbo Pascal」は、版を重ねるにつれてモジュール機能やオブジェクト指向の拡張を加え、「Pascal処理系の実装としての名前」というよりも「Pascal を拡張した言語の名前」となった。オブジェクト指向の拡張はやがてObject Pascalという言語として認知されるようになった。BorlandはObject Pascalの開発環境をより充実させた製品としてDelphiをリリースした。しばらくは言語名はObject Pascalであるとしていたが、バージョン7で言語名もDelphiに変更した（言語そのものには、バージョンアップ以上の大きな変化は無い）。
Turbo Pascal と Delphi の成功によって、互換を謳った実装が OS/2 や UNIX 上でも開発されている。商用のものとしては Speed Pascal、Virtual Pascal があり、フリーソフトとしては Free Pascal（元 FPK Pascal）が広い範囲のプラットフォームで動作する。ISO 標準 Pascal を意識したものでは、GNU Pascal がある。また、Borland自身がDelphiをベースにして作ったGNU/Linuxシステム向け開発環境のKylixもある。
以上のように「Borlandの成功」が語られがちではあるが、実際のところ、Turbo Pascalの開発者であるアンダース・ヘルスバーグは、1990年代にMicrosoftに移籍している。ヘルスバーグはMicrosoftでVJ++などを担当した後、C#を開発している。C#は、C++とJavaの基本文法や特徴をベースに、ヘルスバーグの経験が反映された設計がなされており、DelphiおよびBorland C++ Builderの影響もあるが、「Object Pascal のブロック表記などをC言語風に置き換えた」と説明するのは間違っている。
当初、Macintosh にはセルフ開発環境はなく、システムの開発およびアプリケーションのクロス開発用プラットフォームとして、もっぱら Lisa を使用した。Lisa の公式開発言語は Pascal だったため Macintosh Toolbox と呼ぶ API においても、その呼び出し手法が Pascal に準拠していたのはこうした理由による。
なお、この Macintosh の開発言語は原初の Pascal ではなく、ヴィルト自身が拡張した Object Pascal である。codice_3 を codice_4 に拡張し、GUI 環境構築の記述に実用性を持たせたものである。
ニクラス・ヴィルト自身によって、Pascalや他の言語の経験にもとづき、後継と言える言語が設計されている。Pascalとの互換性を残した拡張といったようなスタイルではなく、そのため名前にもPascalを含めていない。
その他の言語ないし実装
「本物のプログラマはPascalを使わない」というエッセイは、そのタイトルだけは有名だが、Pascalについては実のところ、構造化プログラミングの代名詞のような感じで引き合いに出されているだけであり、その内容についても、当のハッカーたちからも否定と肯定が半々といった所である（例えばジャーゴンファイルでは、用語集本体では否定的に、附録では肯定的に言及している）。
本格的な批判の文章としては、カーニハンによる"Why Pascal is Not My Favorite Programming Language"がある。
