Forth
Forth（フォース）は、スタック指向のプログラミング言語およびそのプログラミング環境である。Forth はしばしば、かつての習慣に従ってすべて大文字で綴られることもあるが、頭字語ではない。
Forth はスタック指向であり、逆ポーランド記法（RPN）と同様の後置記法による記述が一番の特徴である。その他の特徴としては、手続き型・命令型であり、言語としては全ての値は型としての区別なく扱われること（型システムが無いこと）、制御構造などもプログラム可能であること（リフレクション）といったものがある。
典型的な Forth の実装には、LISP におけるw:Read–eval–print loop（REPL）に対応する、入力されたワードを即座に実行する対話型のインタプリタモードと（これは、正規のオペレーティングシステムがないシステム向けのシェルにも適している）、後の実行のために一連のワードをコンパイルするモードのふたつのモードがある。後者にはコロン（:）というワードにより遷移しセミコロン（;）というワードで脱する。
初期の実装や移植性を目的とした実装にはスレッデッドコードを生成するものもあるが、近年の実装では他の言語のコンパイラのように最適化された目的コードを生成するものもある。
他の言語のシステムほどは人気はないが、商用においても Forth はいくつもの言語のベンダを引き止めるだけの十分なサポートを持っている。Forth は現在 Open Firmware のようなブートローダや宇宙開発、組込みシステム、ロボット制御などに使われている。GNUプロジェクトによる実装であるGforthは活発にメンテナンスされており、最新のリリースは2008年の12月である。
Forth の環境はコンパイラと対話形式のシェルが一体化している。実行時環境に似ている仮想マシンにおいて、ユーザは対話的に定義し、「ワード」(words) ともサブルーチンを実行する。ソースコードとしてテスト、再定義、デバッグされることができるワードは、プログラム全体を再コンパイルしたり再起動することなく組み込まれる。変数、基本的な演算子など、すべての構文要素はプロシージャのように見える。たとえ特定のワードが最適化されても、サブルーチンの呼び出しを必要とするといけないので、これもまた依然としてサブルーチンとして有効である。言い換えれば、シェルは対話的に入力されたコマンドをそれが実行される前にマシンコードにコンパイルする（この振る舞いは一般的だが、必須ではない）。どのように結果のプログラムが格納されるかはForth 環境によってさまざまだが、理想的には手動でそのコードが再入力されたときとプログラムの実行は同じ影響を持つ。コンパイルされる関数はプログラムオブジェクトの特殊なクラスで対話的コマンドは厳密にインタープレットされる、C言語とUnixシェルの組み合わせとは対照的である。ほとんどのForth のユニークな性質はこの原理の結果である。対話性、スクリプティング、コンパイレーションがあることにより、Forth は BBC Micro や Apple II シリーズのようなリソースが限られたコンピュータでよく使われ、ファームウェアや小さなマイクロコントローラなどのアプリケーションで生き残っている。Cコンパイラがよりコンパクトで効率的なコードを生成しようとしている今まさにそのときでも、Forth の対話性における優位は保たれているのである。
再帰的なサブルーチンを持つすべてのプログラミング環境は制御フローのためにスタック (stack) を実装している。この構造は典型的にはローカル変数やサブルーチンの引数も格納する（C言語のようなシステムにおける call-by-value）。Forth にはしばしばローカル変数がないこともあるが、call-by-value でもない。代わりに、中間的な値は第二のスタックにおいて保持される。ワードはスタックの最も上にある値を直接操作する。それゆえ、これは「パラメータ」または「データ」スタックと呼ばれたりもするが、ほとんどの場合は単に「スタック」である。それから、関数呼び出しスタックは「リンケージ」(lincage) もしくは「リターン」(return) スタックと呼ばれ、"rstack" とも略される。カーネルから提供された特殊な rstack 操作関数はそれがワード内で一時的なストレージとして使われることを可能にするが、その一方でこれは引数や操作データを渡すことに使うことはできない。Forthはスタックの概念をうまく利用しており、演算は逆ポーランド記法により記述される。このため構文解析が極めて単純となり、プログラムおよび処理系が小さくて済む。これは、機器組み込み用プログラムでは有利な特徴である。
また、ルーチンは「ワード」単位で記述され、コンパイルされる。これらの「ワード」を集積して「ディクショナリ」を形成する。一般的なFORTH処理系におけるプログラミングは、インタプリタ上でのワード作成の積み重ねであり、対話的に行える。開発中でも部分的な処理を動かしてのテストがやりやすく、それらを適宜組み合わせてのテストも容易である。
ほとんどのワードはスタック上でのその効果の観点から定義される。典型的には、引数はワードが実行される前にスタックの一番上に置かれる。実行後は引数は消去され、何らかの返り値で置き換えられている。数学的な操作をするためには、これを逆ポーランド記法のルールに従う。スタックの使用法を図解した以下の例を参照すること。
Forth は単純だが拡張性のある言語である。そのモジュール性と拡張性はCADシステムのような高度なプログラミングをも可能にする。しかしながら、拡張性は未熟なプログラマがわかりにくいコードを書くのも促すため、このことは Forth に「記述専用言語」との評判ももたらしている。大規模で複雑なプロジェクトでも成功裏に使われてきていて、有能でよく訓練されたプロフェッショナルによって開発されたアプリケーションが、何十年にもわたって発展していくハードウェアプラットフォーム上でも容易に保守されることを証明している。Forth は天文学分野や宇宙開発分野という得意分野も持っている。
その移植性、効率的なメモリ使用、短い開発期間および高速な実行スピードのため、Forth は今日でもいまだ多くの組み込みシステム(小さなコンピュータ化されたデバイス)で使われている。これは近代的なRISCプロセッサ上で効率的に実装されてきており、マシン語としてのForthの利用も生み出されてきている。他の Forth の用途としてはアップル、IBM、サン・マイクロシステムズ、OLPC XO-1に使われるOpen Firmware ブートロムが含まれる。また、FreeBSDオペレーティングシステムのFICL-based first stage boot controllerもある。
Forth はチャールズ・ムーアの1958年から絶え間なく開発されていた個人的なプログラミングシステムから考案された。1968年、家具と絨毯を扱う企業に雇われた際、このソフトウェアをミニコン上でFORTRANを使って書き直したものがForthの原型である、という。Forth が他のプログラマに最初に公開されたのは1970年代で、アメリカ国立電波天文台にいたアメリカの Elizabeth Rather によって始められたものである。1971年にアメリカ国立電波天文台の制御用ソフト作成において、ムーアはFORTHを完成させた。このNRAOにいた彼らの仕事のあと、チャールズ・ムーアとElizabeth RatherはFORTH, Inc. を1973年に設立し、その後の 10 年でさらに磨きをかけるとともにいくつものプラットフォームに Forth システムを移植した。
1968年の"[t]he file holding the interpreter was labeled FOURTH, for 4th (next) generation software — but the IBM 1130 operating system restricted file names to 5 characters."において Forth は命名された。ムーアは compile-link-go 第三世代プログラミング言語の後継、または「第四世代」ハードウェアのためのソフトウェアとして Forth を見ており、用語として使われるようになっていた第四世代プログラミング言語 (4GL) ではなかった。ムーアは、アセンブラ・FORTRAN・BASICに続く4番目の言語という意味で、このソフトウェアに「fourth」と名付けるつもりだったが、このミニコンで取り扱えるファイル名は最大5文字であったため「FORTH」という名になったという。
チャールズ・ムーアはたびたび仕事を渡り歩いていたため、初期の言語開発の困難は異なるコンピュータアーキテクチャへの移植の容易さであった。Forth システムはしばしば新しいハードウェアを育てるために使われていた。たとえば、Forthは1978年の新しい Intel 8086 チップ上の最初の常駐ソフトウェアで、MacFORTHは1984年の最初のアップルMacintoshの最初の常駐開発システムあった。
Forth, Inc の microFORTH は1976年に始まったIntel 8080, Motorola 6800, Zilog Z80 マイクロプロセッサ向けに開発された。MicroFORTH は　後に 1978年の 6502 のような他のアーキテクチャ向けの Forth システムを生成するのにホビーストたちにも使われた。広い普及は最終的に言語の標準化を誘導することとなった。共通の慣習は事実上の標準である FORTH-79 および FORTH-83 にそれぞれ1979年、1983年に成文化された。これらの標準は1994年に ANSIによって統合され、通常これは ANS Forth（ANSI INCITS 215-1994 (R2001)、ISO/IEC 15145:1997(E)のベースとなった）と呼ぶ。
Forth は1980年代にはとてもよく使われるようになったが、これは小さくかつ移植性が高いとして当時の小さなマイクロコンピュータにとてもよく適していたからである。すくなくともひとつのホームコンピュータ、英国のJupiter ACEは　そのROM常駐オペレーティングシステムに Forth を持っていた。キヤノン・キャットもまた そのシステムプログラミングのために Forth を使っていた。さらに Rockwell も常駐 Forth カーネルを持つ R65F11 と R65F12 のシングルチップマイクロコンピュータを製造していた。
Forthの後置記法は、データスタック（オペランドスタック、以下単にスタックと呼ぶ）を意識的に操作しなければならないというForthの特徴と密接に結びついている。すなわち、オペランドはそのままスタックに積まれ、後から現れる演算子などはスタックからそれを取り出して演算し、結果をスタックに積む、といったように動作する。多くの言語と違い、バッカス・ナウア記法で構文が定義されているわけでもなく、伝統的にはコンパイラは、スレッデッドコードと呼ばれるシンプルな構造の目的コードを直接生成するだけである。また、文法の修正のような、多くの言語では実装の内部に手を入れる変更が必要なことが、Forthではそのようなワードを定義することで可能である（これは、Lispのマクロに少し似ている）。なお、データスタックの他にリターンスタックがあり、そちらはワードの呼出しの後で手続きを再開するアドレス等が積まれるスタックである（CPUのいわゆるスタックに似ている）。
たとえば、codice_1 は、次のように入力して計算する（「<cr>」は、改行の入力。「ok」はForth処理系が結果の出力の後に付けるプロンプト）。
まず最初に数値 25 と 10 がこの順でスタックに積まれる。
ワード codice_2 がスタックの一番上にあるふたつの数を乗算し、その積に置き換える。
それから数値 50 をスタックに積む。
ワード codice_3 がこれに先ほどの積を加算する。最後に、codice_4 コマンドがスタックのトップを取り出して、それを、ユーザの端末に結果として出力する。
これは、スタックに4を積み、さらに5を積み、スタック上の2つの値を取り出して加算、その結果をスタックに戻し、スタックの値を表示する操作を示している。
上記のように入力してエンター（リターン）を打鍵すると、画面上には下記のように結果が表示される。
Forth の構造化機能でさえもスタックベースである。たとえば、
このコードは 次のコマンドを使うことによって codice_5 が呼ばれる新しいワード（繰り返すが、「ワード」という単語はサブルーチンとして使われている）を定義する。codice_6はスタックの数値を複製する。codice_7がスタックの一番上に 6 を配置する。ワード codice_8 はスタックの一番上の二つの数（6 と codice_6 で複製された入力の値）を比較し、真偽値で置き換える。codice_10は真偽値をとり、その直後のコマンドを実行するか、codice_11までスキップするかを選択する。codice_12はスタックの上の値を放棄する。そして、codice_13は条件分岐の終端である。括弧に囲まれたテキストは、このワードが期待するスタックの数と値を返すかどうかを説明するコメントである。ワード codice_5 はC言語で書かれた次の関数に相当する。
この関数はより簡潔につぎのように書かれる。
このワードは次のように実行できる。
最初にインタプリタは数値（1 もしくは 8）をスタックにプッシュし、それからこの数値を再びポップし結果をプッシュする FLOOR5 を呼び出す。最後に、「.」の呼び出しは値をポップし、ユーザの端末にそれを表示する。
Forth の構文解析は明確な文法がないので単純である。インタプリタはユーザ入力デバイスから入力された行を読み、それから区切り文字としての空白を使って単語に構文解析される。他の空白文字を認識するシステムもある。インタプリタがワードを見つけると、ディクショナリ (dictionary) からそのワードの検索を試みる。もしそのワードが見つかれば、インタプリタはワードに関連付けられたコードを実行し、それから入力システムの残りを構文解析するために復帰する。もしワードを発見することができないなら、ワードを数だと仮定して数値への変換を試み、それをスタックにプッシュする。これが成功すれば、インタプリタは入力システムからの構文解析を継続する。辞書の参照と数値への変換の両方が失敗した場合、インタプリタはそのワードが認識できないというエラーメッセージに続けてそのワードを表示し、入力ストリームをフラッシュし、ユーザからの新しい入力を待機する。
新規ワードの定義は、ワードcodice_15（コロン）から始まり、codice_16（セミコロン）で終了する。たとえば、
のコードはワード codice_17 をコンパイルし、辞書にこの名前が発見できるようにする。コンパイルと言っても、文頭にコロン、その後にワードの名称を置き、そこから一連の式を並べておいて、文末にセミコロンを付加するだけでよい。codice_18 をコンソールに入力して実行すると、codice_19 が表示されるようになるだろう。
例えば、前述の式をfooという語（ワード）としてコンパイルするには、以下の通り記述する。記述法はコロン記号で始まりセミコロン記号で終わるので、「コロン定義」と呼ばれる。
コンパイルすることにより、FORTHの辞書（ディクショナリ）に、この語（ワード）が登録されることになる（この場合はfooが登録される）。
実のところ、FORTHでは「+」や「.」などの演算子や出力機能などの全てがワードである。こういった組み込み済みのワードと、ユーザが後からコロン定義（コンパイラ）で追加したワードと、2つの間に本質的な差異はない。コンパイルしたワードはただちに環境に組み込まれ、インタプリタより単独で実行できるようになる。つまり、そのFORTH処理系を拡張するのである。このような点より、FORTHは自己拡張性が高いと云われる。
プログラムの開発においては、処理毎に区切ってワードとして順次構築していくので、注意深く進めていけば自然ときれいに構造化されることになる。ワードは単独で実行できるため、部分に分けてのデバッグも容易である。また、それらのワードを使ってテスト用の処理（ワード）を気軽に作成して実行・テストできる。
多くの Forth システムは実行可能なワードを生成する特殊化されたアセンブリ言語を含む。このアセンブラはコンパイラの特殊な方言である。Forth アセンブラはしばしば命令の前に引数がくる逆ポーランド記法を使う。Forth アセンブラの普通の設計では命令をスタック上に構築し、それからこれを最後の段階でメモリにコピーする。Forth システムでは、番号（0..n, 実際のオペレーションコードとして使われる）付けされるかその目的に応じて名づけられた、製作者によって使われる名前でレジスタは参照されることもある。たとえば、スタックポインタとして使われるレジスタは「S」など。
古典的な Forth システムでは伝統的にオペレーティングシステムもファイルシステムも使われない。コードはファイルに格納される代わりに、ソースコードは物理的なディスクアドレスに書かれたディスクブロックに格納される。ワード codice_20 はディスクスペースの1キロバイトサイズのブロックの数値からデータを格納しているバッファのアドレスへの変換に割り当てられ、Forth システムによって自動的に管理される。固定されたディスクブロック範囲にファイルが配置されるときには、システムのディスクアクセスが使われる実装もある。たいていはこれらはディスクブロックごとのレコードの整数をつかって、固定長バイナリレコードして実装される。高速な検索はキーデータ上のハッシュアクセスによって実現される。
ふつうは cooperative なラウンドロビンスケジューリングであるマルチタスクは、通常利用可能である（ただし、マルチタスキング・ワードとサポートは ANSI Forth 規格ではカバーされていない）。ワード codice_21 は、次のタスクの配置や実行コンテキストのリストアための　現在のタスクの実行コンテキストの保存に使われる。どちらのタスクも自分自身のスタックやいくつかのコントロール変数のコピー、スクラッチエリアを持っている。タスクのスワップは単純で、効率的である。その結果、Forth マルチタスクは Intel 8051, Atmel AVR, and TI MSP430のような非常に単純なマイクロコントローラでさえ有効である。
その一方で、Microsoft WindowsやLinux、Unixのようなホストオペレーティングシステムのもとで実行され、ソースやデータのファイルのためにホストオペレーティングシステムのファイルシステムを利用する Forth システムもある。ANSI Forth 規格では　I/O のために使われたワードについて書かれている。他の標準的でない機能はホスト OS やウィンドウシステムへのシステムコールを発行するためのメカニズムも含み、多くはオペレーティングシステムから提供されるスケジューリングを採用する拡張を提供する。典型的には、タスク作成、一時停止、解体、および優先順位の変更のために、スタンドアロンのForthの codice_21ワードとは大きくて異なったワードのセットを持っている。
すべてのソースコードとともに十分な機能を有する Forth システムは自身をコンパイルすることができ、Forth プログラマはこのようなテクニックを普通メタ・コンピレーション (meta-compilation) と呼ぶ（ただし、この用語は普通の定義であるメタコンピレーションとは厳密には一致しない）。通常の方法はコンパイルされたビットをメモリに配置する一握りのワードの再定義である。コンパイラのワードはメモリ内のバッファエリアにリダイレクトされることができるフェッチとストアの、特別に命名されたバージョンを使う。このバッファエリアはコードバッファというより異なるアドレスから始まるメモリ領域へのシミュレートやアクセスをする。このコンパイラは対象のコンピュータのメモリとホストの（コンパイルする）コンピュータのメモリの両方にアクセスするワードを定義する。
フェッチやストア操作がコード空間に再定義されたあと、コンパイラやアセンブラなどはフェッチやストアの新たな定義を使って再コンパイルされる。これはコンパイラとインタプリタのすべてのコードの効果的な再利用である。それから、Forth システムのコードはコンパイルされるが、このバージョンはバッファに格納される。このメモリ内のバッファはディスクに書きこまれ、これをテストのために一時的にメモリにロードする方法が提供される。新たなバージョンがきちんと機能するようなら、これは以前のバージョンに上書きされる。
異なる環境のためのバリエーションが多数存在する。組み込みシステム向けには、代わりに他のコンピュータのためにコードが書かれることになるが、このテクニックはクロスコンピレーションとして知られ、シリアルポートや単独の TTL ビット越しでさえ、その上オリジナルのコンパイルするコンピュータのワード名やディクショナリの他の実行されない部分も維持する。このようなForthコンパイラのための最小の定義は　バイト単位のフェッチやストアをするワードと、実行される Forth ワード を命令するワードである。しばしばもっとも多くの時間のかかるリモートのポートへの書き込みの部分は、フェッチやストア、実行を実装するための初期化プログラムの構築であるが、多くの現代的なマイクロプロセッサ（Motorola CPU32など）は、このタスクを排除する統合されたデバッグ機能を持っている
Forthの基本的なデータ構造は、「ワード」を実行可能なコードや名前のつけられたデータ構造を対応させる「ディクショナリ」である。このディクショナリは、門番（通常は NULL ポインタ）が発見されるまで最も新しく定義されたワードから最も古いワードまで進むリンクを用いた連結リストのツリーとして、メモリに展開される。コンテキストスイッチは異なる葉で開始するためにリスト検索を引き起こす。首位のメインの幹への枝のマージは最終的にルートの門番へ戻ってくるので、連結リスト検索は継続する。そこはさまざまなディクショナリになることができる。メタコンピレーションのような稀なケースでは、ディクショナリは隔離されスタンドアロンである。この効果は名前空間のネストのそれに似ていて、コンテキストに依存するキーワードのオーバーロードが可能である。
定義されたワードは一般的にヘッドとボディからなり、ヘッドは名前フィールド (NF) とリンクフィールド (LF) からなり、ボディはコードフィールド (CF) とパラメータフィールド (PF) からなる。
ディクショナリのエントリのヘッドとボディは、隣接していないかもしれないので別々に扱われる。たとえば、Forth プログラムが新しいプラットフォームのために再コンパイルされたとき、ヘッドはコンパイルするコンピュータに残るかもしれないが、ボディは新しいプラットフォームに行ってしまっている。組み込みシステムのようないくつかの環境によっては、ヘッドは不必要にメモリを占有する。しかしながら、もしターゲット自身が対話的なForthをサポートすることを期待されるなら、クロスコンパイラによってはヘッドをターゲット内に配置するかもしれない。
ディクショナリの厳密なフォーマットは規定されず、実装に依存する。しかしながら、いくつかのコンポーネントはほとんどいつも提示しており、しかし、厳密なサイズと順序は変わるかもしれない。記述された構造、ディクショナリエントリはこのように見えるかもしれない。
この名前フィールドはワードの名前の長さ（典型的には32バイト）を与えるプリフィックスで開始し、何ビットかはフラグ用である。それからワードの名前の文字表現がプリフィックスのあとに続く。特定のForth実装に依存するが、アラインメントのためひとつ以上の NUL ('0') バイトがあるかもしれない。
リンクフィールドは以前に定義されたワードへのポインタを含む。このポインタは次に古い隣接するワードへの、相対的な変位かもしれないし、絶対的なアドレスかもしれない。
このコードフィールドポインタは　コードを実行するワードのアドレスか、パラメータフィールド内のデータか、プロセッサ直接実行するであろうマシンコードの開始のいずれかになるだろう。ワードを定義するコロンでは、コードフィールドポインタはリターンスタック上の現在の Forth 命令ポインタ (instruction pointer, IP) を保存し、ワードを実行継続するための新たなアドレスを用いてIP をロードするワードを指し示す。これはプロセッサの call/return 命令が行っているのと同様である。
コンパイラ自身はモノリシックなプログラムではない。これは システムから可視な Forth ワードとプログラマから利用可能なものとからなっている。このことはプログラマが特殊な目的のためにコンパイラのワードを変更することを可能にする。
名前フィールド内の「コンパイル時」フラグは、「コンパイル時」の振る舞いのワードのセットである。ほとんどの単純なワードは、それがコマンドライン上で入力されたかコードに埋め込まれたかにかかわらず、同じコードが実行される。そのようにコンパイルされるとき、コンパイラはコードかワードへのスレッデッドポインタを単に配置する。
コンパイル時ワードの古典的な例は codice_10 and codice_24 といった制御構造である。Forth のすべての制御構造とほとんどすべてのコンパイラはコンパイル時ワードとして実装される。すべての Forth 制御フローワードは、プリミティブなワードcodice_25やcodice_26（もしfalseなら分岐する）の各種の組み合わせをコンパイルするために、コンパイルの間に実行される。コンパイルの間、データスタックは制御構造のバランシング、ネスティング、ブランチアドレスのバックパッチングをサポートするのに使われる。コード断片
は定義の内側では典型的には次のような一連にコンパイルされる。
codice_25のあとの数のは相対的なジャンプアドレスを表している。codice_28は「リテラル」数値をデータスタックにプッシュするためのプリミティブなワードである。
ワード codice_15（コロン）は名前を引数として構文解析し、辞書にヘッダを作り（記述法はコロン記号で始まりセミコロン記号で終わるので、コロン定義, colon definition）、コンパイル状態に突入する。コンパイラは後続のワードをコンパイルしていく。このときワードが後述する即時ワードである場合は実行し、そうでない場合は実行時に呼び出されるようにコンパイルする。
ワードcodice_16（セミコロン）は現在の定義を終了し、実行状態へと復帰する。
システムの状態はワード codice_31（左大括弧）及び codice_32（右大括弧）を用いて手動で変更させることができ、それぞれ実行状態とコンパイル状態に突入する。ANS Forthでは、現在のインタプリタの状態はフラグ codice_33から読み取ることができ、コンピレーションステート状態 true、そうでなければ false の値がこいる。をこのインタプリタの現在の状態による振る舞いコンパイル時ステートスマートワード (state-smart words) の実装を可能にする。
ワードcodice_34は、直近のコロン定義を、即時ワードにする。即時ワードは通常はコンパイル後ではなくコンピレーションの間に実行されるが、どちらのステートにおいてもプログラマにオーバーライドされることができる。codice_16 は即時ワードの一例である。ANS Forth では、ワードがイミディエイトとしてマークされていても、ワード codice_36 は名前を引つけられたワードのコンピを強制的にコンパイルする。
ANS Forth では、ワード codice_37 を用いて、次のcodice_16（セミコロン）までの後続のワードをコンパイルし、実行トークン (execution token) をデータスタック上に残す、無名のワードが定義できる。
ワード codice_39 はデータスタックから実行トークンを取り出し、関連づけられたセマンティクスを実行することができる。またワード codice_40（COMPILE コンマ）は、データスタックから実行トークンを取り出し、コンパイルする。
ワード codice_41 (tick) は、ワード名を引数としてとりデータスタック上のワードに関連づけられた実行トークンを返す。
ワード codice_15 (colon)、codice_36、codice_41 (tick)と codice_37 は、データスタックの代わりにユーザからの入力からそれらの引数をとる構文解析ワード (parsing words) の例である。別の例では、コロン定義において、次の右括弧を含む後続のワードを読み込んで無視し、コメントを配置するのに使われる codice_46（左括弧）がある。同様に、ワード codice_47（バックスラッシュ）は現在の行の終端まで続くコメントのために使われる。
ほとんどの Forth システムにおいて、コード定義のボディはマシン語といくつかの形式のスレッデッドコードからなる。非公式の FIG 規格 (Forth Interest Group) のあとに続くオリジナルの Forth は、TIL (Threaded Interpretive Language) である。これは indirect-threaded code とも呼ばれ、direct-threaded と subroutine threaded Forths も現在はよく使われるようになってきた。最初期のモダンな Forth は subroutine threading を使っており、マクロとしてシンプルなワードを挿入し、コードをより小さく早くするために peephole optimization や他の最適化戦略を実行した。
ワードが変数や他のデータオブジェクトであるとき、CPはそれを作成した定義ワードに関連付けられたランタイムコードを指している。定義ワードは特徴的な"defining behavior"（ディクショナリエントリの作成に加え、もしかしたらアロケートとデータ領域の初期化をする）を持っており、この定義しているワードによって構築されたワードのクラスのインスタンスの振る舞いの定義もする。たとえは、
Forth は、カスタム定義の振る舞いとインスタンスの振る舞いを指定する、新しいアプリケーション特有の定義ワードをプログラマが定義できる機能もまた提供する。円形バッファ、I/Oポート上で命名されたビット、自動的にインデックス化された配列などの例がある。
これらに定義されたデータオブジェクトと同様のワードはスコープにおいてグローバルである。他の言語でローカル変数から提供された関数は、Forth ではデータスタックから提供される（しかし、Forth も真のローカル変数は持っている）。Forth のプログラミングスタイルは他の言語に比べ、ごく少数の名付けられたデータオブジェクトを使う。典型的にはこのようなデータオブジェクトは、たくさんのワードやタスク（マルチタスクの実装においては）によって使われるデータを格納するのに使われる。
Forth は型システムを持たない。したがって値の操作は全てプログラマの責任で行われる。
Forth で書かれたワードは実行可能な形式にコンパイルされる。古典的実装は、順に実行されるワードのアドレスのリストをコンパイルする。多くの現代的なシステムは実際のマシンコードを生成する（いくつかの外部ワードの呼び出しと、適当な場所に展開された他者のためのコードを含む）。最適化コンパイラをもつシステムもある。一般的な場合、Forth プログラムは実行可能形式としてロードされたとき実行されるコマンド (e.g., RUN) を含めた、Forthプログラムのコンパイル済みコードのメモリイメージとして保存されている。
開発中、プログラマは小さなコード片を開発したときに実行およびテストするためにインタプリタを使う。そのため、ほとんどの Forth プログラマは緩やかなトップダウン設計と、単体テストと統合の繰り返しによるボトムアップ開発を支持している。
トップダウン設計では、普通まずプログラムを「語彙」へのプログラムを分割し、それらを最終的に必要なプログラムを書くための、高レベルなツールセットとして利用する。よく設計された Forth プログラムは自然言語のように読むことができ、単一の目的を達成するために用いられるだけでなく、関連する問題を解くプログラムを書くのに利用することができる。
"For an explanation of the tradition of programming "Hello World", see Hello world."
実装の一つとしては、
ワード codice_53 (Carriage Return) は後続の出力を新しい行の上に表示するようにする。構文解析ワード codice_54 (dot-quote) はダブルクオートで区切られた文字列を読み、構文解析された文字列が実行時に表示されるように現在の定義にコードを追加する。文字列 codice_55 からこの空白文字で区切っているワード codice_54 は、文字列には含まれていない。これは構文解析器が codice_54 を Forth ワードとして認識するために必要である。
標準的な Forth システムはインタプリタでもあり、同じ出力は次のコード片を Forth コンソールに入力することで得ることができる。
codice_58 (dot-paren) は括弧で囲まれた文字列を構文解析し、これを表示するイミディエイトワードである。codice_54と同様に、codice_55 から空白文字で区切られたcodice_58 は文字列の一部ではない。
ワード codice_53 は表示する文字列の前にくる。慣例的に、Forth インタプリタは新規行に出力を開始しない。また、慣例により、インタプリタは直前の行の終端、codice_63プロンプトの後で入力を待つ。他のプログラミング言語で時々そうであるような、Forth の codice_53 にはバッファをフラッシュする暗黙の動作はない。
ここに 実行されると単一の文字 codice_65 を発行するワード codice_66 の定義がある。
この定義は codice_65 のASCII値 (81) を直接を使うことで書かれている。括弧の間の文字列はコメントで、コンパイラに無視される。ワード codice_68 はデータスタックから値をとり、対応する文字を表示する。
次の codice_66 の再定義は、ワードcodice_31（左大括弧）、codice_32（右大括弧）, codice_72、codice_73 をインタプリタステートを一時的に切り替えるために使っており、文字 codice_65 のAscii値を計算し、コンピレーションステートを返し、計算した値を現在のコロン定義に追加する。
構文解析ワード codice_72 は空白で区切られたワードをパラメータとしてとり、データスタック上のその最初の文字の値を置く。ワード codice_76 は codice_72 のイミディエイトバージョンである。codice_76を使って、codice_66 の定義例は次のように書くことができる。
この定義はコメントを書くために codice_47（バックスラッシュ）を使っている。
codice_72 と codice_76の両方は ANS Forth では事前に定義される。codice_34 と codice_36 と使って、codice_76 はこのように定義することができる。
1987年、Ron Rivest は RC4 暗号システムを RSA Data Security, Inc. のために開発した。このコードは非常に単純で、説明を読めば大抵のプログラマは書くことができる。
それぞれすべて値の異なった 256 バイトの配列がある（訳注:これが暗号ストリームの状態であり、鍵で適当に初期化する）。
この配列が使われるときはいつも、2つのバイトが交換されることによって変更される。
この交換はカウンタ "i" および "j" によって制御され、どちらも最初は 0 である。
新しい "i" を取得するには 1 を加算する。
新しい "j" を取得するには、新しい "i" の位置にある配列のバイトを加算する。
"i" と "j" の位置にある配列の値を交換する。
このコード（訳注:後のXORに使う値）は "i" と "j" の位置にある配列のバイトの和の位置にある配列のバイトである。
平文を暗号化したり暗号文を復号するためには、このバイトを XOR される。
配列は最初の設定によって 0 から 255 にかけて初期化される（訳注:手順の途中に書いてあるが、これは最初に行う）。
それから "i" と "j" を使う、"i" の位置にある配列のバイトを "j" に加算による新しい "j" とキーのバイトの取得、"i" と "j" のバイトの交換と手順は進んでいく。
最後に、"i" と "j" は 0 にセットされる。
すべての加算は 256 を法とするモジュラ演算である。
以下の標準の Forth バージョンはコアのワードのみを使っている。
これはこのコードを検証する多くのテストのひとつである。
Forth 仮想マシンは実装が単純で規格のリファレンス実装を持たないため、大量の言語実装が存在する。標準的な各種デスクトップコンピュータシステム (POSIX, Microsoft Windows, macOS) をサポートしていることに加え、これらの多くの Forth システムは各種の組み込みシステムもまた対象としている。1994年の ANS Forth 規格に準拠するさらに有名ないくつかのシステムが列挙する。
