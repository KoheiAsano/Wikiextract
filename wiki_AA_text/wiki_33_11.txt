Intel 8086
Intel 8086（インテル8086）はインテルが開発した16ビット マイクロプロセッサ(CPU)。x86(80x86)アーキテクチャの最初のマイクロプロセッサで、1978年に発表された。
日本電気のPC-9801などパーソナルコンピュータに広く採用された。対応するオペレーティングシステムに、MS-DOS、PC-DOS、CP/M-86があった。
シリーズには、外部データバスを8ビットにした低価格版の8088があり、初代のIBM PCにも採用された。協調して働くように準備されていた数値演算コプロセッサに8087があった。また、使われる機会は少なかったが、8089というI/Oプロセッサも存在した。
当時ライバルとされた製品には、モトローラの68000系プロセッサがある。
8086は8ビットアーキテクチャであった8080を16ビットに拡張し、乗除算などの命令を強化したCPUである。アドレスバスは20ビットに、データバスは16ビットに拡張された(姉妹品に外部データバスを8ビットに留めた8088もある)。8080とバイナリーレベルの互換性はないが、開発にあたってIntelは、8080からの速やかな移行を最重点事項に置き、8080のアセンブラソースコードに一切の手を加えることなく再アセンブルするだけで、8086用のバイナリを生成する事も出来た。
8080のアーキテクチャと大きく異なるのは、演算用のアドレスレジスタのほかに、セグメントレジスタという、アドレス変換のための16ビットのレジスタを持っていることである。実際にCPUがアクセスするアドレスは、16ビット幅のレジスタによって指定された64KBのアドレスに、さらに16ビット幅のセグメントレジスタの値を16倍（左に4ビットシフト）して加算したアドレスとするため、1MBのメモリ空間を利用できた。
8086のアーキテクチャでは、プログラム内で通常表現されるアドレスの値は16ビット幅で64KBのメモリ空間である。当時、64KBのメモリ空間は1つのプログラムにとっては十分に広大であり、セグメント機構はマルチタスクのために用意された。(8086には保護がないので、アプリケーションがセグメントレジスタを操作できるが、本来はOSが操作するものである。) 内蔵する4本のセグメントレジスタの値を全て同一にすると、8ビットの8080と同等の環境となり、8080用ソースを8086へ移植するのが容易であるほか、実行バイナリのリロケータブル化が容易であるといったメリットもあった。
しかし、8086や、その互換品・後継品がロングセラーになって使われ続けた結果、より大規模なプログラムが作られる様になると、64KBのメモリ空間は狭くなってしまい、アプリケーションのプログラムが自力でセグメントレジスタを操作して64KB以上のメモリ空間にアクセスする手法が用いられるようになった。しかし、頻繁にセグメントレジスタを操作することはプログラムを煩雑にし、実行時のオーバーヘッドも増えるため、プログラマからは非常に嫌われた。
後に批判の的となってしまったセグメント方式だが、互換性を重視しつつ開発が短期間で完了でき、かつコストパフォーマンスに優れた選択肢であった。これは、当時モトローラと激しいシェア争いを演じていたintelにとって極めて重大な要素だった。
メモリ空間を1MBとしたのは、当時使われていた40DIPパッケージにアドレス・データバスを割り当てる際に、アドレスピンを効率良く増やして割り当てられる値であったとも言われる。
また、より大容量のアプリケーションを担い、高性能を発揮する次世代のプロセッサとしては、当時計画中であった32ビットCPU、iAPX432を充てる事が考えられていた。当初、8086は8ビットアーキテクチャから次世代のiAPX 432プロセッサへのつなぎとして考えられていたため、後に大規模な拡張を行う事は一切考えられていなかった。
演算に使えるレジスタが限定的だったり、メモリを直線的に使うのが面倒等の問題があったものの8080とのソースレベルでの互換性を重視し、既存の8080環境やCP/Mなどのアプリケーションの移植、プログラマの移行などにも積極的であったことから、IBM-PCへ採用され、現在のx86アーキテクチャの商業的な成功へとつながったと評価されている。
ハードウェア的には、供給クロックのデューティ比が1:2になっている。クロックジェネレータi8284に3倍のクロックを供給し、それを3分周することにより1:2のクロックを得る。
C言語から生成されたプログラムにおいて、コードとデータのそれぞれで、デフォルトのアクセスをセグメント内のオフセットのみとするか、セグメントも併用してアクセスするか、の違いにより「コード・データともセグメント内」「コードのみセグメント内」「データのみセグメント内」「コード・データともセグメント併用」といったパターンが存在し、ライブラリ等はそれぞれ異なるものを使うため煩雑であった。デフォルトでないアドレッシングには、ポインタに codice_1 や codice_2 という修飾を付ける。プログラミングモデルあるいはメモリモデル等ともいう。
詳細は以下の通り。
効率などの理由から、コンパイルはSmallモデルとし、必要に応じて明示的にセグメント操作をプログラマが指示する（適宜farまたはhugeポインタを使用し、また動的なメモリ確保によって64KBの制限を超える）ような作りのプログラムも多い。
8086の外部データバスは16ビットであるが、アドレッシングは8ビット単位で行われ、データバスの下位8ビットが偶数アドレス、上位8ビットが奇数アドレスとなる。
8086でシステムを構築する上で、従来からある8ビットCPU用の周辺チップ（8251、8255、8257、8259など）が多用されたが、これらのデータバスは8ビットであるため、8086に接続するには、8086のデータバスの上位もしくは下位8ビットのどちらかに接続することになった。
そのため、このような構成では、8086 CPUから見ると、周辺チップの連続するレジスタが偶数アドレスもしくは奇数アドレスのみにとびとびに割り当てられる格好となる。
PC-9800シリーズでは実際に上記のような構成になっており、I/Oマップが偶数アドレスと奇数アドレスで分断されている。
一方、外部データバスが8ビットの8088を採用したIBM PCではそのようなことはなく、8ビットの周辺チップは連続したアドレスに存在する。XTバスの拡張カードにより増設した機器も同様である。
そのため、後にPC/ATで16ビットのISAを採用した際に、8ビットの周辺機器をサポートするためにバス・サイジングの必要性が生じた。
また、PC-9800シリーズでも、PCカードのモデムなど、IBM PCシリーズ用に開発された8ビットの周辺機器をサポートする際に、バス・サイジングの必要性が生じた。
