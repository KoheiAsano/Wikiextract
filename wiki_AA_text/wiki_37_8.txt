浮動小数点数
浮動小数点数（ふどうしょうすうてんすう、英: floating point number）は、浮動小数点方式による数のことで、もっぱらコンピュータの数値表現において、それぞれ固定長の仮数部と指数部を持つ、数値の表現法により表現された数である。
指数表現によって可能な十分に広い絶対値の範囲内において、仮数部の桁数に依って常に一定の範囲内の相対誤差で任意の実数を近似できるという特性がある。そのため、極端な数を扱う分野（科学計算など）で多く用いられている。また、プログラミング言語のほとんどが対応しているということもあり、小数の表現方法としては最も普及している。
整数演算と同じ操作で処理が済む固定小数点と違い、通常の整数演算命令を使って実装すると、多くの命令と時間が必要になる。処理の軽減のため、演算にはハードウェアで実装したFPUなどのコプロセッサを用い、現在のマイクロプロセッサなどの多くでは内蔵されていることが多い。
なお、この記事では固定精度の浮動小数点数のみ扱う。任意精度の浮動小数点については任意精度演算を参照のこと。
浮動小数点数では次のデータで数値を表現する。
現在広く使われている表現方法ではいずれも基数を固定しており、明示的に符号化しないため、実際に符号化されるのは、次の3つである。
浮動小数点数では、数値の絶対値は（仮数部）×（基数）となる。たとえば、0.5を浮動小数点数で表すと、基数が10の場合は5.0×10（5.0e-1）、基数が2の場合は1.0×2となる。
2進法で正規化をすると、最上位ビットは常に1になるので、これを表さず常に1があるものとみなす省略が可能で、省略した表現をケチ表現などと言う。この省略を使うと、仮数部に割り当てたビット数がnであれば、有効桁数はn+1となる。
0を表す場合は符号部、仮数部、指数部のすべてのビットを0とすると都合が良いことからそのようにされることが多い。またその場合は+0.0で、浮動小数点では他に符号部が負をあらわし他が0の-0.0という0もあることがある。たとえば正の数を負の無限大で割ったり、負の数を正の無限大で割ったりすると-0.0になる。
浮動小数点数のフォーマットには、以下で説明する次のようなものをはじめとして多数あるが、現在ではほぼ標準であるIEEE 754に収束し、その他は（専用ハードウェアや、特殊用途や研究目的といったものを除き）歴史的な理由で残されているにすぎないものがほとんどである。
IEEE 754 形式の
で表現されている。各部は次のように定義されている。
つまり、IEEE 754 形式で表現する値は
である。
ただし、IEEE 754 形式の指数部は複雑で、以下のような役割も持つ。
0 を 0 で割ろうとすると NaN になる。また、formula_1 も、求めるとNaNになる。
2.5を例にとると、
であることから、まず次のように考える。
仮数部は1未満でなければならないため、仮数の値2.5を（この例では右へ）シフトし正規化する。基数は2、コンピュータの内部表現は2進法であるため、シフト量は1ビットである。さらに、右シフトしてになったことを相殺するため、指数に1を加える（もし左シフトなら、指数から1を引く）。
値をシフトすることで表現範囲を広げ、丸め誤差を少なくなるようにしている。この操作を正規化という。正規化は基数の±1乗を繰り返し求めればよい。
このままでは (-1)×1.25×2 となり、仮数の絶対値は1未満ではないが、仮数部は 仮数 - 1 と決められているため、次のようになる。
指数部は、指数に127をバイアスすることが決まっているため
2進法では、
浮動小数点は、最上位ビットから符号部、指数部、仮数部の順に符号化するため
IBM方式は、IBM社がSystem/360で導入し、以後同社の標準としてSystem/370などのメインフレームで使った方式である（1994年4月発表のSystem/390では、従来形式のサポートは残すもののIEEE 754を使用するよう改めた）。指数部が2の冪ではなく16の冪を表すという特徴がある。この方式は、より大きな範囲を少ないビット数の指数部で表すことができ、そのぶんのビットを仮数部の桁数に使うことで精度も確保できるように一見思える。しかし、仮数部にケチ表現を使うことができず、さらに指数部の変化の前後で、仮数部のLSBが表現する値の刻み幅が16倍変化するため、2べきの場合に比べて最悪の場合には2進で3ビット分の精度が損なわれるため、一般には大成功であったと評されたSystem/360の設計において良くなかった点の一つとして挙げられる。（浮動小数点数の加減算の際に必要となる仮数部のシフトが4ビット単位となるのでシフト回数が減ることで演算が程度高速になる利点も16進数が採用された理由であった。）
特に単精度において、前世代機の（全部で36ビット）よりも桁数を減らした（32ビット）ことと相まって精度が大きく損なわれた。その他にも問題があり、ユーザグループであるSHAREから改善提案が出され、その多くを受け入れて多大なコストのかかる改修をおこなったほどであり、これを記憶しているIBMの古参社員は「身の縮む思い」をおぼえているという。
また、計算対象の数値がベンフォードの法則に従って分布していた場合、計算対象として精度の低い数（仮数部の最上位4ビットが0b0001）の現れる確率は1/15にはならず、もっと高い。
IBM方式の単精度浮動小数点数では、符号部1ビット、指数部7ビット、仮数部24ビットで表現されている。各部は次のように定義されている。
符号部は仮数の符号を表す。
指数部は-16～-16と16～16の範囲が表現できる。
1.5を単精度のIBM方式で表現するには、次のようになる。
仮数部は1未満でなければならないため、値を（この例では右へ）シフトする。ただし、基数が16で、コンピュータの内部表現は2進法であるため、シフト量は4ビットである（2 = 16）。加えて正規化し、その結果は次の通り。
次に指数部を、64をバイアスしたゲタ履き表現（エクセス64）で表現する。バイアスにより、0～127のビットパターンで、整数値-64～+63を表現するということになる（-64 + 64 = 0、63 + 64 = 127）。
よって、今回の例では以下のようになる。
2進法では、
浮動小数点は、最上位ビットから符号部、指数部、仮数部の順に符号化するため
任意精度演算と、従来の指数部と仮数部を共に固定長とする形式の中庸と言えるような方式が、いくつか提案されている。絶対値が1に近い値では指数部の桁数を短くし、仮数部の桁数を多くとって、よく使われる値を精度よく表現する。絶対値が極端に大きい値や小さい値には、精度とひきかえに指数部の桁数を増やすことで対応する。以下で述べる方式を提案している文献では、アプリケーションとして、通常の浮動小数点計算には、指数が大きくなり過ぎることがあって向かないとされているw:Graeffe's methodをうまく扱えたという例が示されている。
松井正一と伊理正夫が提案した方式で、符号と絶対値による表現法である。論文中に示された例では、64ビットの倍精度浮動小数点数として、仮数部の長さnを示す情報6ビットと、（符号部を含む）mビットの指数部とnビットの仮数部（m+n = 58）から成る。彼らは、オーバーフローを起こさせないための、より大きい数やより小さい数の表現や、無限大などの例外的な値を含めた算術（IEEE標準の±∞や-0の扱いに似ているが、より拡張されている）も提案しているが、ここでは割愛する。
浜田穂積が提案した方式で、Universal Representation of Real numbersの意でURRと名付けられている。-∞ ～ 0 ～ ∞ の区間を、次のように分割しながら、二進法による表現に対応付ける、というのが基本的な考え方で、「符号と絶対値」形ではなく、浮動小数点の表現としては比較的珍しい2の補数の形をしている。
ここで±1の前後は、区間の両端の比が2なので、指数部の表現は終わったとみなすことができ、残りの桁は仮数部のように扱う（±1の前後は、以後は1/2で等差分割する）。次のように分割を続ける。
以降は、0 ～ 0.25 と 4 ～ ∞ の区間に絞って説明する。
ここで、4 = 2、16 = 2 である。このように 0 や ±∞ を含む区間は「二重指数分割」する。
このように、区間の両端の比が2より大きい場合は、「等比分割」する。
以上のような操作の結果として、表現が自然に自分の長さを含むような指数部と、残りの仮数部から成る、と見ることができるような表現が得られる。
利点として、単精度と倍精度、さらには4倍精度との相互変換が、この方式では単に右にビットを伸ばしたり切り落としたりするだけで良い、という点が挙げられる。また、1の近くでは桁数のほとんどが仮数部となるので精度が高い。
欠点としては、精度が変化するため従来の精度一定を前提としたノウハウに修正が必要かもしれない、-∞を除くワードのあらゆるビット表現に浮動小数点数としての意味が与えられるため、例外的な値を表現する方法を別に考えなければいけない、などといった点がある。浜田は1000...を符号なしの∞（射影モード用。符号なしの0と対応する）とし、表現可能な最大と最小の絶対値を持つ値を、具体的にその値を表すのではなく±∞と±0を表現するものとする（0は、通常の0を符号なしの0とし、符号付きの+0や-0は、無限大で割った結果など例外的な値としてのみ現れる）、という方法を提案している。
この表現法の初出は1981年だが、1983年に改良版が提案されているのでそちらをまずは参照すべきである。
いくつかの実装の報告や改良の提案がある。
32bit-floatの場合には156[dB]、64bit-floatの場合には331[dB]もの広いダイナミックレンジを確保できる。
この広いダイナミックレンジで計算を行うことで、整数型のデータに変換して信号を出力する際に内部計算において累積した誤差を切り捨てることにより、出力データの精度の範囲内においては内部計算の誤差が現れないように処理を行うことが可能となる。
製品に収録する音声信号フォーマットに直す直前まで波形がクリップせず音声加工処理を行えるメリットが有るため、2000年代以降はDTMやDAWにおいては全ての処理工程で浮動小数点数を用いている。
従来よりDSPや音楽用ワークステーション等では、精度と計算コストの兼ね合いから32bit-floatが内部計算において標準的に用いられてきたが、2010年代以降はコンピュータの高性能化と低価格化を受けて、より高精度な64bit-floatで内部計算を行う場合が増えて来ている。
浮動小数点数を表現するための仮数部の桁数の関係で、32bit-integerよりも32bit-floatの方が量子化ノイズが大きい。従って、最終的に32bit-integerのデータを作成する場合には、内部計算においては64bit-float以上の精度を持つ浮動小数点数を用いるべきである。
