Ruby
Ruby（ルビー）は、まつもとゆきひろ（通称 Matz）により開発されたオブジェクト指向スクリプト言語であり、スクリプト言語が用いられてきた領域でのオブジェクト指向プログラミングを実現する。
また日本で開発されたプログラミング言語としては初めて国際電気標準会議で国際規格に認証された事例となった。
Ruby は1993年2月24日に生まれ、1995年12月にfj上で発表された。名称の Ruby は、プログラミング言語 Perl が6月の誕生石である Pearl（真珠）と同じ発音をすることから、まつもとの同僚の誕生石（7月）のルビーを取って名付けられた。競合言語として Perl の他に Python があり、「Matz（まつもと） が Python に満足していれば Ruby は生まれなかったであろう」と公式のリファレンスの用語集で言及されている。
機能として、クラス定義、ガベージコレクション、強力な正規表現処理、マルチスレッド、例外処理、イテレータ、クロージャ、Mixin、利用者定義演算子などがある。Perl を代替可能であることが初期の段階から重視されている。Perlと同様にグルー言語としての使い方が可能で、C言語プログラムやライブラリを呼び出す拡張モジュールを組み込むことができる。
Ruby 処理系は、主にインタプリタとして実装されている（詳しくは#実装を参照）。
可読性を重視した構文となっている。Ruby においては整数や文字列なども含めデータ型はすべてがオブジェクトであり、純粋なオブジェクト指向言語といえる。
長らく言語仕様が明文化されず、まつもとによる実装が言語仕様に準ずるものとして扱われて来たが、2010年6月現在、JRuby や Rubinius といった互換実装の作者を中心に機械実行可能な形で明文化する RubySpec という試みが行われている。公的規格としては2011年3月22日にJIS規格（JIS X 3017）が制定され、その後2012年4月1日に日本発のプログラム言語では初めてISO/IEC規格（ISO/IEC 30170）として承認された
フリーソフトウェアとしてバージョン1.9.2までは Ruby ライセンス（Ruby License や Ruby'sと表記されることもある。GPLかArtisticに似た独自ライセンスを選択するデュアルライセンス。）で配布されていたが、バージョン1.9.3以降は2-clause BSDLで配布されている。
開発者のまつもとゆきひろは、「Rubyの言語仕様策定において最も重視しているのはストレスなくプログラミングを楽しむことである ("enjoy programming")」と述べている。
ただし、まつもとによる明文化された言語仕様は存在しない。Perlのモットー「やり方はいろいろある ("There's More Than One Way To Do It; TMTOWTDI")」は「多様性は善 ("Diversity is Good")」というスローガンで Ruby に引き継がれてはいるものの最重要なものではないとも述べており、非推奨な手法も可能にするとともに、そのような手法を言語仕様により使いにくくすることによって自粛を促している。
Rubyの公式な実装には、以下の二種類が存在する。
基本的なコード
配列の作成と使用法
ほかの言語でもよくみられるような制御構造を用いることができる。
一部の制御構造は後述するイテレータで代替することができる。
Ruby ではブロック付きメソッド呼び出しを用いるコードが好まれることが多い。これを用いると、ユーザー定義の[[制御構造]]や[[コールバック (情報工学)|コールバック]]など様々な処理を簡潔に記述できるからである。
ブロックとは波括弧 、 または 、 によって囲まれたコード列のことである。メソッド呼び出しの末尾に記述することが出来る。この2つは基本的に同一だが、結合の優先度が異なる。一行で書くときは波括弧が、複数行に渡る場合は、が使用される場合が多い。
ブロック付きメソッド呼び出しが繰り返し処理を主な役割としていたことから、イテレータと呼ばれていた時期がある。しかし、実際には繰り返し処理にとどまらず、様々な使われ方をしているので、最近はブロック付きメソッド呼び出し全体の総称としてイテレータという名称を用いるのは適切でないと考えられている。
配列の各要素への繰り返し処理
以下はブロックを使わずに同じことを行う場合
指定した回数の繰り返し処理
ブロックの内容を実行してから、決められた後処理を行うメソッドもある
これは次の例と同様の処理を行う（codice_1 については例外処理の項を参照）
実際に行いたい処理をブロックで記述する。前項の後処理の省力化もこれの一例といえる。
この例は、ツリーから要素と分枝をつぎつぎと取り出して取り出したものになんらかの処理を行うものである。メソッドの利用者は、なんらかの処理のみを記述すればよく、取り出しのアルゴリズムなど、本質的でない内容に意識を向ける必要がなくなる。
クロージャとなるようなブロックの引数渡し
メソッドからクロージャを返す例
次のコードはcodice_2という名前のクラスである。その中、まずcodice_3はオブジェクトを初期化するコンストラクタである。ほかに2つのメソッドがあり、1つは比較演算子であるcodice_4をオーバーライドしておりcodice_5によりプロパティcodice_6でソートすることができる。もう1つのオーバーライド箇所のcodice_7メソッドは codice_8 での表示の形式を整える。codice_9は Ruby におけるメタプログラミングの例であり、codice_10 はインスタンス変数の入出力を司る、いわゆる値を取得する codice_11 メソッドや値を設定する codice_12 メソッド（アクセサ）を定義する。codice_9は codice_11 メソッドのみの定義である。なおメソッド中では最後に評価された式が返り値となり、明示的なcodice_15は省略できる。
結果は3つの名前が年の大きい順に表示される
例外はなにか不具合が起こったときcodice_16の呼び出しで発生させることができる。Ruby での例外は codice_17 クラスか、そのサブクラスのインスタンスである。
例外にはメッセージを追加することもできる
さらに例外のタイプも指定できる
例外はcodice_18節で処理することができ、次のようにコードにcodice_18を付加するだけである
Ruby ではブロック構造を codice_20 で終える構文が採用されているが、開発者のまつもとゆきひろは他の構文が採用される可能性があったことを述べている。当時、Emacs 上で codice_20 で終える構文をオートインデントさせた例はあまりなく、Ruby 言語用の編集モードにオートインデント機能を持たせられるかどうかが問題になっていたためである。実際には数日の試行でオートインデント可能であることがわかり、現在の構文になった。C言語のようなcodice_22を使った構文も検討されていたが、結局これは採用されなかった。
