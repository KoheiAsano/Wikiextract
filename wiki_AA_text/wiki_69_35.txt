LISP
は、プログラミング言語である。前置記法などが特徴である。
1958年にはじめて設計されたは、現在広範囲に使用されている高水準プログラミング言語の中でもに次いで2番目に古い。ただし、と同様に、現在のは初期のものから非常に大きく変化している。
これまでに多数の方言が存在してきたが、今日最も広く知られる方言は、とである。
元々、は、アロンゾ・チャーチのラムダ計算表記法に影響を受け、コンピュータープログラムのための実用的かつ数学的な表記法として作られた。そして、すぐに人工知能研究に好まれるプログラミング言語になった。最初期のプログラミング言語として、は計算機科学にて、木構造、ガベージコレクション、動的型付け、条件分岐、高階関数、再帰、セルフホスティング、コンパイラを含む多くのアイディアを切り開いた。
の名前は、「」に由来している。リストはの主要なデータ構造であり、ソースコードはそれ自体がリストからできている。その結果、LISPプログラムはソースコードをデータとして操作することができ、プログラマーは、マクロ・システムで新しい構文や埋め込みの新しいDSLを作成できる。
コードとデータの互換性は、にそのすぐに認識できる構文を与える。すべてのプログラム・コードはS式または入れ子のリストとして書かれる。関数呼び出しまたは構文は先頭が関数または演算子の名前で、その続きが引数であるリストとして書かれる。具体的には、3つの引数を取る関数codice_1は、codice_2として呼び出される。
は1958年にジョン・マッカーシーがMITにいた期間に考案された。マッカーシーは1960年にACMの学会誌に「」という題名の論文（「パートII」が発表されることはなかった）を発表した。この論文において（それを言語とみなし純LISPとも言われるが）少数の単純な演算子と関数の表記法で、自分自身を評価するcodice_3関数（超循環評価器）を記述できることが示された。
1955年または1956年からはじまった、IPLは、最初の人工知能言語で、リスト処理や再帰などの多くの概念をすでに含んでいたが、その後すぐにそういった分野ではが使われるようになった。
前述の超循環評価器はLISP自身で実装されているが、ひとたび以外の言語で実装すればそれは実際にを解釈実行できるインタプリタとなる。マッカーシーは自分の論文中にある評価器は単なる理論上の存在で、そのようにしてインタプリタを実装可能であると考えていなかった。しかし、マッカーシーのもとで大学院生であったスティーブ・ラッセルは論文を読んだ後、機械語でそれを実装してみせ、マッカーシーを驚かせた。そうしてインタプリタが生まれた。
超循環評価器は、チューリングマシンにおける万能チューリングマシンに相当する。（当初プログラムの表現法としていた）M式を、自身が扱うデータ構造に変換したS式は、万能チューリングマシンの入力（テープの初期状態）として与えられるチューリングマシンの記述に相当する。マッカーシーはやはり、プログラムのS式による表現はcodice_3を考えるための論文の中だけのものと考えており、実際のプログラムをS式で書くようになるとは考えていなかった。
は当初IBM 704上で実装されたが、その計算機のレジスタを構成する部分の名前が、対を分解する関数codice_5、codice_6の名前の由来となった。爾来、ほとんどのの方言において、codice_5とcodice_6はそれぞれlistの最初の要素と、最初の要素以外を返す関数の名前となっている。
その発端からは、人工知能研究のコミュニティ、特にPDP-10システムのユーザーには近しい存在であった。PDPの計算機の設計目標の一つにLispの実装があり、PDP-6は当初、1ワード24bitの計算機として設計されていたが、Lisp1.5を移植しやすくするために36bitに変更された。人工知能コミュニティでは、はプログラミング言語の実装用言語としても用いられた。有名なAIシステムの実装言語のは、で実装されている。
また、1970年代には、で実装されたや、等の数式処理システムの需要が高まるにつれ高速なの処理系の需要も高まり、を高速に処理するいわゆるマシンの動機の一つとなった。マシンは、タグアーキテクチャや、ハードウェアスタック等LISP向けのハードウェア機構により、型のディスパッチや関数呼出し、ガベージコレクションの高速化を実現した。
は実装の容易さゆえに非常に多くの方言を生んだ。マクロを用いれば文法構造それ自体を拡張できるので、ある意味では利用者ごとに方言があるとさえいってよい。1970年代から1980年代にかけては、大きく分けて系と系の二つの主流が存在し、後の方言に影響を与えている。
1980年代と1990年代には、たくさんの方言を一つの言語に統合しようという努力がなされた。その結果として設計された新しい言語は基本的にそれらの方言のスーパーセットであり、それらを置き換えることになった。1994年にはの標準仕様「」を出版した。しかし、このときまでには、全盛期に比べるとの市場は小さくなっていた。
一方で1970年代中ごろには、ベースでプログラミングに必要な言語機能を極限まで抽象化したが発生し、こちらも現在の主流の一つになっている。
は現在でも広く使われている年代物の言語の一つである。
は「式指向」の言語である。他の多くの言語とは違って、式と文は区別されず、すべてのコードとデータは式として書き下される。式が評価されたとき、それは値（または値のリスト）を生成する。式は他の式に埋め込める。
マッカーシーの1958年の論文では、2つのタイプの表現が導入されている。内部のデータ構造の表現であるS式（記号式、、）と、S式を引数に取りS式を返す関数を表す、外部表現であるM式(メタ式、）である。マッカーシーは、S式はプログラムの処理対象のデータの表現に使い、プログラムの表現にはM式を使った。S式によるプログラムの表現は論文の中のみのものと考えていた。しかし、S式で表現されたプログラムを評価するevalが実装され、S式で表現することでプログラムをプログラムで操作できるという利点があり、今日ではほとんどすべての言語でM式は使用されておらず、プログラムとデータの両方にS式を使用する。
の用いる S式は括弧を大量に使用するため、批判を受けることもある。「 は 『』（過剰でいらいらさせる大量の括弧）に由来する」というジョークもある。しかし、S式による構文はの能力を生み出してもいる。この構文は極めて正規化されているので、コンピュータによる操作が容易に行える。
式への依存が、に優れた柔軟性を与えている。の関数は、それ自身がリストとして書かれており、データとまったく同様に扱うことができる。のプログラムは他のプログラムを処理するように書くことができる。これは、メタプログラミングと呼ばれる。多くの 方言はこの機能をマクロシステムで活用しており、言語自身の機能をほとんど際限なく拡張することを可能にしている。
でのリストは空白と括弧で区切られた要素で記述される。たとえば、
はcodice_9, codice_10, codice_11の値を要素として持つ1つのリストである。これらの値は暗黙の型を持つ。これらは2つの整数と1つの文字列であるが、そのように宣言されている必要はない。空のリストcodice_12はcodice_13とも書ける。
現実の実装では、上記のリストを直接処理系に入力するとエラーが起きる。
これは、上のcodice_14は正しい式ではないからである。処理系の中で上のリストを表現したい場合は、クオート「'」を用いてcodice_15と書く必要がある。このことを解説するため、ここででの評価ルールについて述べる。
すべての式は前置記法のリストとして書かれる。リストの最初の要素は"フォーム"（関数、演算子、マクロ、特殊フォームのいずれか）の名前である。リストの残りは引数である。たとえば、関数codice_16はその引数をリストとして返す。つまり式
は評価されてリストcodice_15を返す。このことを念頭に置いて、もう一度最初に挙げた式を振り返ると、
という仕組みでによりエラーが返されたことがわかるだろう。
もし引数のどれかが式であれば、それを含む式が評価される前にそれが再帰的に評価される。たとえば、
はリストcodice_18に評価される。つまり、3番目の引数はリストであり、リストはネストできるのである。
算術演算も同様に処理される。式
は10に評価される。この式は中置記法では「formula_1」と等価である。
特殊形式（）は制御構造など、引数の位置にあるものを通常のようには評価しないような機能を提供する。たとえば、codice_19は3つの引数をとり、
第一引数の値が真なら第二引数に、偽なら第三引数に評価される。ここで真とはcodice_13以外、偽とはcodice_13のことである。したがって式
はcodice_22に評価される。codice_23は、その第一引数が偶数であるときにtを、
奇数の時nilを返す関数である。5は奇数なので、第一引数codice_24を評価したcodice_19は、その第三引数codice_26を返す。
関数の定義には、特殊形式codice_27によって
のようにして、関数を表現する。この例は、ラムダ計算における
codice_28をで表現したものである。
特殊形式codice_29で関数を定義すると、関数に名前を付けて定義できる。codice_29の引数は引数のリストと、関数として評価される式である。
以下の5つの関数と特殊形式、他にシンボルのcodice_13とcodice_32、などがあれば自分自身を解釈実行できるevalを実装できる。このことはある意味で万能チューリングマシンと同様のことであると言える。
以下にいくつかののコード例を示す。これらは産業界における典型的なコードではないが、コンピュータサイエンスのコースで通常教えられる典型的なコードである。
の構文はそれ自身が再帰的定義に自然に適合している。それゆえ、再帰的に定義された集合を列挙するというような数学の問題をシンプルに表現できる。
以下の関数は引数の階乗に評価される。
下記は別のやり方であり、末尾再帰になっている。
再帰と対照的な概念である反復による計算の例として、の代表的な繰り返し構文であるcodice_41マクロを使った例を示す。
codice_41はマクロであり、これが展開されて最終的にはプリミティブな構文の組み合わせに翻訳される。
以下の関数は引数にリストをとり、そのリストの要素の順番を逆にしたものに評価される（は実際には同じことを行うビルトイン関数を普通持っている）。
以下を含む多種のオブジェクト指向あるいはモジュールがの上に、あるいは併置して、あるいは組み込まれて設置されている。
は多重継承と多重ディスパッチ（マルチメソッド）の機能を持ち、強力なメソッド結合()のシステム()を持つ。を含めたは、公式に標準化された最初のオブジェクト指向言語である。
