C Sharp
C#（シーシャープ）は、アンダース・ヘルスバーグが設計（デザイン）したプログラミング言語であり、構文（syntax）は（名前にもある通り）C言語や、C言語風に構文が設計されたC++やJavaなどの影響があるが、構文以外についてはヘルスバーグが以前の所属であるBorlandで設計したDelphiからの影響がある。
Microsoftによる謳い文句としては、マルチパラダイムプログラミング言語、強い型付け、命令型、宣言型、手続き型、関数型、ジェネリック、オブジェクト指向の要素を持つ、などといった点が強調されている。
CLIといった周辺も含め、Microsoftのフレームワーク「.NET Framework」の一部である他、VJ++で「非互換なJava」をJavaに持ち込もうとしたような以前のMicrosoftとは異なり、その多くの仕様を積極的に公開し標準化機構に託して自由な利用を許す（ECMA-334、ISO/IEC 23270:2003、JIS X 3015）など、同社の姿勢の変化があらわれている一面でもある（実際に「Mono」という、フリーソフトウェアの定義に合致したライセンスの、コミュニティによる実装がある）。
開発にはボーランド社のTurbo PascalやDelphiを開発したアンダース・ヘルスバーグを筆頭に多数のDelphi開発陣が参加している。
C#は共通言語基盤（共通言語ランタイムなど）が解釈する共通中間言語にコンパイルされて実行される。
自動ボックス化、デリゲート、
プロパティ、インデクサ、カスタム属性、ポインタ演算操作、構造体（値型オブジェクト）、多次元配列、可変長引数、などの機能を持つ。また、Javaと同様に大規模ライブラリ、プロセッサ・アーキテクチャに依存しない実行形態、ガベージコレクション、JITコンパイルによる実行の高速化、などが実現されている（もっともこれらはC#の機能というより.NET Frameworkによるものである）。
.NET構想における中心的な開発言語であり、XML WebサービスやASP.NETの記述にも使用される。他の.NET系の言語でも記述可能だが、生産性・機能においてC#が最も優れるとされる。マイクロソフトの統合開発環境では、Microsoft Visual C#がC#に対応している。
共通言語仕様のCLSによって、他のCLS準拠の言語（Visual Basic .NETやVisual C++ (C++/CLI)など）と相互に連携することができる。他言語で記述されたクラスを継承することも、またその逆も可能である。
さまざまな意味において、基盤であるCLIの機能をもっとも反映している言語であるといえる。C#にある組み込み型のほとんどは、CLIフレームワークに実装されている値型と対応している。しかし、C#の言語仕様はコンパイラのコード生成については何も言及していない。つまり、CLRに対応しなければならないとか、共通中間言語 (CIL) などの特定のフォーマットのコードを生成しなければならないとかいうことは述べられていない。そのため、理論的にはC++やFORTRANのように環境依存のマシン語を生成することも可能である。しかし、現在存在するすべてのC#コンパイラはCLIをターゲットにしている。
C#では、CやC++と比較してさまざまな制限や改良が加えられている。その例を次に挙げる。
部分型 () が導入された。以下のようにクラスや構造体の宣言にcodice_18修飾子をつけることで、その宣言を分割することができる。
これは以下と同義である:
これによって、巨大なクラスを分割したり、自動生成されたコードを分離したりすることができる。codice_18 修飾子はすべての宣言につける必要がある。
ジェネリクスが導入された。これは.NET Framework 2.0の機能である。クラス、構造体、インタフェース、デリゲート、メソッドに対して適用することができる。.NETのGenericsはC++のテンプレート、あるいはJavaにおけるそれとも異なるもので、コンパイルによってではなく実行時にランタイムによって特殊化される。これによって異なる言語間の運用を可能にし、リフレクションによって型パラメタに関する情報を取得することができる。また、codice_20節によって型パラメタに制約を与えることができる。一方、C++のように型パラメタとして式を指定することはできない。なお、ジェネリックメソッドの呼び出し時に引数によって型パラメタが推論できる場合、型パラメタの指定は省略できる。
静的クラスが導入された。codice_21属性をクラスの宣言につけることで、クラスはインスタンス化できなくなり、静的なメンバしか持つことができなくなる。
codice_22キーワードによるコルーチンを使うことで、イテレータを楽に実装できるようになった。
クロージャの機能を提供する匿名デリゲートが導入された。
プロパティのcodice_23 もしくは codice_24アクセサのどちらかにアクセス修飾子を指定することでアクセス制御が別個にできるようになった。次の例では、codice_23アクセサはcodice_17、codice_24アクセサはcodice_28である。
nullを保持できる値型、codice_29が導入された。
codice_30はcodice_31の糖衣構文である。また、nullを保持しているNull許容型のインスタンスをボックス化しようとすると、単に空参照 (null) に変換される。
また、null結合演算子 (codice_32)が導入された。これは、codice_33でない最初の値を返す。
この演算子は主にcodice_29型を非codice_29型に代入するときに使われる。
codice_36 キーワードが導入され、型推論を利用したローカル変数の宣言ができるようになった。
拡張メソッドが導入された。既存のクラスを継承して新たなクラスを定義することなく新たなインスタンスメソッドを追加定義することができる。具体的には、独自の静的クラス内に codice_37 修飾子をつけた、拡張メソッドを追加する対象の型の引数を最初に持つメソッドを定義することによって、通常の静的メソッドとしての呼び出しの他に指定した型のインスタンスメソッドとしての呼び出しを行うことができるメソッドを作ることができる。以下に例を挙げる:
この例は codice_38 型に、文字列 （codice_38 型のインスタンス）を指定した回数繰り返したものを返すメソッド codice_40 を追加している。このメソッドは、以下のように呼び出すことができる:
また、列挙型やインターフェースなど本来メソッドの実装を持ち得ない型に、見かけ上インスタンスメソッドを追加することも可能である。以下に例を挙げる:
このメソッドは以下のように呼び出すことができる:
部分メソッドが導入された。部分型（codice_18 型）内で定義された codice_28 で、かつ戻り値が codice_43 のメソッドに codice_18 修飾子をつけることでメソッドの宣言と定義を分離させることができる。定義されていない部分メソッドは何も行わず、何らエラーを発生させることもない。例えば:
上のコードにおいて codice_45 を呼び出すと、Did something. と表示されるだけだが、ここで以下のコード:
を追加した上で codice_45 を呼び出すと、[DEBUG: Some message] Did something. と表示される。
匿名メソッドをより簡略化した記法として、ラムダ式が導入された。この名前はラムダ計算に由来する。
以下の匿名メソッド
は、ラムダ式を使って次のように記述できる:
ラムダ式は匿名メソッドと同様に扱えるが、式形式のラムダがcodice_47型として扱われた場合のみ匿名メソッドとして扱われず、コンパイラによって式木を構築するコードに変換される。匿名デリゲートが実行前にコンパイルされたCILを保持するのに対し、式木はCILに実行時コンパイル可能であるDOMのような式の木構造そのものを保持する。これはLINQクエリをSQLクエリなどに変換する際に役立つ。
以下は、3つの任意の名前の変数、整数、括弧、及び四則演算子のみで構成された式を逆ポーランド記法に変換する汎用的なコードである:
オブジェクトの初期化が式として簡潔に記述できるようになった。
また、コレクションの初期化も同様に簡潔に記述できるようになった。
但し、上のコードでは匿名の変数に便宜的に __p、__l、__d と命名している。実際はプログラマはこの変数にアクセスすることはできない。
プロパティをより簡潔に記述するための自動実装プロパティが導入された。プロパティの定義に codice_48 と記述することで、プロパティの値を保持するための匿名のフィールド（プログラマは直接参照することはできない）と、そのフィールドにアクセスするためのアクセサが暗黙に定義される。また、C# 5.0 までは codice_49とcodice_50のどちらか片方だけを記述することは出来なかったが、C# 6.0 からは codice_49 のみが可能。以下のコード:
は、以下のようなコードに相当する動作をする:
但し、上のコードでは匿名のフィールドに便宜的に codice_52 と命名している。実際はプログラマはこのフィールドにアクセスすることはできない。
一時的に使用される型を簡単に定義するための匿名型が導入された。以下に例を挙げる:
上の式は、以下の内容のクラスを暗黙に定義する。定義されたクラスは匿名であるが故にプログラマは参照できない。
同じ型、同じ名前のプロパティを同じ順序で並べた匿名型は同じであることが保証されている。即ち、以下のコード:
において、codice_53 は codice_54 である。
codice_55 キーワードを用いた配列の宣言の際、型を省略できるようになった。匿名型の配列を宣言する際に威力を発揮する。
LINQ をサポートするために、クエリ式が導入された。これは SQL の構文に類似しており、最終的に通常のメソッド呼び出しに変換されるものである。以下に例を示す:
上のコードは以下のように変換される:
C# 3.0で追加された構文の多くは式であるため、より巨大な式（当然クエリ式も含まれる）の一部として組み込むことができる。旧来複数の文に分けたり、作業用の変数を用意して記述していたコードを単独の式としてより簡潔に記述できる可能性がある。
出井秀行著の『実戦で役立つ C#プログラミングのイディオム/定石&パターン』（技術評論社、2017年）という書籍ではクエリ構文よりメソッド構文を推奨しており、クエリ構文ではLINQの全ての機能を使用できるわけではないこと、メソッド呼び出しは処理を連続して読める可読性があること、メソッド呼び出しであればMicrosoft Visual Studioの強力なインテリセンスが利用できることを理由に、著者はクエリ構文をほとんど使用していないと記している。
dynamicキーワードが導入され、動的型付け変数を定義できるようになった。dynamic型として宣言されたオブジェクトに対する操作のバインドは実行時まで遅延される。
VBやC++に実装されているオプション引数・名前付き引数が、C#でも利用できるようになった。
ジェネリクスの型引数に対してin、out修飾子を指定することにより、ジェネリクスの共変性・反変性を指定できるようになった。
静的 using ディレクティブを利用することで、型名の指定無しに他クラスの静的メンバの呼び出しを行えるようになった。<br>
利用するにはcodice_56の後に完全修飾なクラス名を指定する。
codice_57の後にcodice_58キーワードを使用することで、処理する例外を限定することができるようになった。
codice_59引数で値を受け取る場合、その場所で変数宣言可能となった。
codice_60式の構文が拡張され、型の後ろに変数名を宣言できるようになった。
拡張されたcodice_60式はマッチした場合に宣言した変数にキャストした値を代入し、さらにtrueと評価される。
マッチしなかった場合はfalseと評価され、宣言した変数は未初期化状態となる。
codice_62文のマッチ方法が拡張され、codice_63ラベルに従来の「定数パターン」に加え、新たに「型パターン」を指定できるようになった。
また、「型パターン」のcodice_63ラベルでは、codice_58句に条件を指定することができる。
「型パターン」を含むcodice_62文では、必ずしも条件が排他的でなくなったため、最初にマッチしたcodice_63ラベルの処理が実行される。
タプルのための軽量な構文が導入された。
従来のcodice_68クラスとは別に、codice_69構造体が新しく追加された。
2個以上の要素を持つタプルのための記法が導入された。
引数リストと同様の形式で、タプルを記述できる。
多値戻り値を簡単に扱えるように、分解がサポートされた。
分解はタプルに限らない。codice_70メソッドが定義されたクラスでも、分解を利用できる。
以下に、codice_71型に分解を導入する例を示す。
上記のコードでcodice_71型にcodice_70拡張メソッドを定義し、
のように左辺で3つの変数に値を受け取ることができる。
分解、out引数、パターンマッチングで、値の破棄を明示するためにcodice_74が利用できるようになった。
破棄された値は、後で参照することはできない。
codice_75キーワードの使用方法が拡張された。<br>
これによって、安全な参照の使い道が広がった。
戻り値の型をcodice_75で修飾することで、オブジェクトの参照を戻り値とすることができる。
変数の寿命は変わらないため、メソッド終了時に破棄されるローカル変数をref戻り値とすることはできない。
ローカル変数の型をcodice_75で修飾することで、参照を代入することができる。
Mainメソッドの戻り値として、codice_78型、codice_79型が認められた。
型推論可能な場面では、codice_80の型指定は省略可能となった。
C#7.2で追加された仕様は以下の通り。
値型におけるパフォーマンス向上を意図した複数の機能が追加された。
引数にcodice_81を指定することで、読み取り専用参照渡しを指定できる。
また、戻り値にcodice_82を指定することで、読み取り専用参照戻り値を指定できる。
これにより、構造体のコピーを避けると共に、意図しない値の変更を抑止できる。
構造体宣言時にcodice_83を指定することで、真の読み取り専用構造体を定義できる。
readonly構造体の全てのフィールドはcodice_83でなければならず、codice_37ポインタも読み取り専用となる。
これにより、メンバーアクセス時の意図しない防御的コピーを抑止できる。
構造体宣言時にcodice_75を指定することで、ヒープ領域へのコピーを防ぐ構造体がサポートされる。
ref構造体では、box化できない、配列を作成できない、型引数になることができない、など、ヒープ領域へのコピーを防ぐための厳しい制限がかかる。
この機能は、codice_87のような構造体をサポートするために利用され、unsafe文脈以外でのcodice_88の利用をも可能とする。
C#4.0で追加された名前付き引数が末尾以外でも利用できるようになった。
同一アセンブリ内、かつ、継承先からのアクセス許可を表すcodice_89アクセス修飾子が追加された。
十六進リテラルのcodice_90、二進リテラルのcodice_91の直後のアンダースコアが認められた。
C#の言語仕様は標準化団体Ecma Internationalを通じて公開・標準化されており、第三者がマイクロソフトとは無関係にコンパイラや実行環境を実装することができる。
現段階で、C#コンパイラの実装は次の5つが知られている。
